<!DOCTYPE html>
<html>

<head>
  <title>3D Lab Simulation</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Share+Tech+Mono&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      font-family: 'Rajdhani', sans-serif;
      background: #050a12;
    }

    #menu,
    #labOptions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: white;
      z-index: 10;
    }

    #menu h1 {
      font-size: 52px;
      font-weight: 700;
      letter-spacing: 6px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #00e5ff, #7c4dff, #00e5ff);
      background-size: 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 3s linear infinite;
      margin-bottom: 8px;
    }

    #menu p {
      font-family: 'Share Tech Mono', monospace;
      color: #00e5ff88;
      font-size: 13px;
      letter-spacing: 4px;
      margin-bottom: 40px;
    }

    @keyframes shimmer {

      0%,
      100% {
        background-position: 0%
      }

      50% {
        background-position: 200%
      }
    }

    .btn {
      font-family: 'Rajdhani', sans-serif;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 3px;
      padding: 14px 36px;
      margin: 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.25s;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
    }

    .btn-primary {
      background: linear-gradient(135deg, #00b8d4, #6200ea);
      color: white;
      box-shadow: 0 0 30px #00e5ff44, 0 4px 20px #00000088;
    }

    .btn-primary::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #00e5ff, #7c4dff);
      opacity: 0;
      transition: opacity 0.25s;
    }

    .btn-primary:hover::before {
      opacity: 1;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 50px #00e5ff66, 0 8px 30px #00000099;
    }

    .btn-primary span {
      position: relative;
      z-index: 1;
    }

    .btn-secondary {
      background: transparent;
      color: #00e5ff;
      border: 1px solid #00e5ff55;
      box-shadow: 0 0 20px #00e5ff22 inset;
    }

    .btn-secondary:hover {
      background: #00e5ff15;
      border-color: #00e5ff;
      box-shadow: 0 0 30px #00e5ff44 inset, 0 0 20px #00e5ff22;
      transform: translateY(-2px);
    }

    #labOptions h2 {
      font-size: 28px;
      letter-spacing: 5px;
      text-transform: uppercase;
      color: #00e5ff;
      margin-bottom: 30px;
      font-weight: 600;
    }

    #hud {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      font-family: 'Share Tech Mono', monospace;
      color: #00e5ffbb;
      font-size: 12px;
      letter-spacing: 2px;
      background: #00000088;
      backdrop-filter: blur(10px);
      padding: 10px 24px;
      border-radius: 40px;
      border: 1px solid #00e5ff22;
      z-index: 10;
      text-align: center;
    }

    #hud span {
      margin: 0 12px;
    }

    #hud .key {
      background: #00e5ff22;
      border: 1px solid #00e5ff44;
      padding: 2px 7px;
      border-radius: 3px;
      font-size: 11px;
    }

    #modeIndicator {
      position: absolute;
      top: 20px;
      right: 24px;
      font-family: 'Share Tech Mono', monospace;
      color: #00e5ff99;
      font-size: 11px;
      letter-spacing: 3px;
      background: #00000066;
      backdrop-filter: blur(10px);
      padding: 8px 16px;
      border-radius: 4px;
      border: 1px solid #00e5ff22;
      display: none;
      z-index: 10;
    }

    #entryOverlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center, #050a1200 40%, #050a12 100%);
      pointer-events: none;
      z-index: 5;
    }

    canvas {
      display: block;
      position: absolute;
      inset: 0;
    }
  </style>
</head>

<body>
  <div id="entryOverlay"></div>
  <canvas id="labCanvas"></canvas>
  <div id="menu">
    <h1>MedLab 3D</h1>
    <p>VIRTUAL SIMULATION ENVIRONMENT</p>
    <button class="btn btn-primary" id="playBtn"><span>Enter Lab</span></button>
  </div>
  <div id="labOptions" style="display:none;">
    <h2>Lab Setup</h2>
    <button class="btn btn-secondary" id="notesBtn">Insert Notes</button>
    <button class="btn btn-secondary" id="filesBtn">Upload Files</button>
    <input type="file" id="fileInput" style="display:none;" multiple>
    <br><br>
    <button class="btn btn-primary" id="skipBtn"><span>Skip → Enter Lab</span></button>
  </div>
  <div id="hud">
    <span><span class="key">Click</span> Move</span>
    <span><span class="key">Q/E</span> Turn</span>
    <span><span class="key">5</span> Toggle View</span>
  </div>
  <div id="modeIndicator">FIRST PERSON</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const menu = document.getElementById("menu");
    const labOptions = document.getElementById("labOptions");
    const labCanvas = document.getElementById("labCanvas");
    const hud = document.getElementById("hud");
    const modeIndicator = document.getElementById("modeIndicator");

    // ── ENTRY SCENE ──────────────────────────────────────────────────────────────
    const entryScene = new THREE.Scene();
    entryScene.background = new THREE.Color(0x050a12);
    entryScene.fog = new THREE.Fog(0x050a12, 10, 40);
    const entryCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    entryCamera.position.z = 10;
    const entryRenderer = new THREE.WebGLRenderer({ canvas: labCanvas, antialias: true });
    entryRenderer.setSize(window.innerWidth, window.innerHeight);
    entryRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    const pGeo = new THREE.BufferGeometry();
    const pArr = new Float32Array(600);
    for (let i = 0; i < 600; i++) pArr[i] = (Math.random() - .5) * 30;
    pGeo.setAttribute('position', new THREE.BufferAttribute(pArr, 3));
    entryScene.add(new THREE.Points(pGeo, new THREE.PointsMaterial({ color: 0x00e5ff, size: 0.08, transparent: true, opacity: 0.7 })));
    for (let i = 0; i < 3; i++) {
      const t = new THREE.Mesh(new THREE.TorusGeometry(2 + i * 1.5, 0.04, 8, 80), new THREE.MeshBasicMaterial({ color: i === 0 ? 0x00e5ff : i === 1 ? 0x7c4dff : 0x00b8d4, transparent: true, opacity: 0.5 - i * 0.1 }));
      t.rotation.x = Math.PI / 3 * i; t.rotation.z = Math.PI / 4 * i;
      t.userData.speed = 0.003 + i * 0.002;
      t.userData.axis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
      entryScene.add(t);
    }
    entryScene.add(new THREE.AmbientLight(0x00e5ff, 0.2));
    let entryRunning = true;
    function animateEntry() {
      if (!entryRunning) return;
      requestAnimationFrame(animateEntry);
      const t = Date.now() * 0.001;
      entryScene.children.forEach(o => { if (o.userData.axis) o.rotateOnAxis(o.userData.axis, o.userData.speed); });
      entryCamera.position.x = Math.sin(t * 0.1) * 2;
      entryCamera.position.y = Math.cos(t * 0.07) * 1;
      entryCamera.lookAt(0, 0, 0);
      entryRenderer.render(entryScene, entryCamera);
    }
    animateEntry();

    document.getElementById("playBtn").addEventListener("click", () => { menu.style.display = "none"; labOptions.style.display = "block"; });
    document.getElementById("notesBtn").addEventListener("click", () => { const n = prompt("Insert your note:"); if (n) alert("Note saved: " + n); });
    const fileInput = document.getElementById("fileInput");
    document.getElementById("filesBtn").addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", e => { if (e.target.files.length > 0) { labOptions.style.display = "none"; entryRunning = false; startLabSimulation(); } });
    document.getElementById("skipBtn").addEventListener("click", () => { labOptions.style.display = "none"; entryRunning = false; startLabSimulation(); });

    // ── TEXTURE FACTORIES ────────────────────────────────────────────────────────
    function mkCanvas(w, h) { const c = document.createElement('canvas'); c.width = w; c.height = h; return [c, c.getContext('2d')]; }

    function makeWallTileTex() {
      const [c, ctx] = mkCanvas(512, 512);
      ctx.fillStyle = '#e4ecf0'; ctx.fillRect(0, 0, 512, 512);
      const ts = 64;
      for (let tx = 0; tx < 8; tx++) for (let ty = 0; ty < 8; ty++) {
        const x = tx * ts, y = ty * ts, v = Math.random() * 5;
        ctx.fillStyle = `rgb(${226 + v | 0},${236 + v | 0},${240 + v | 0})`;
        ctx.fillRect(x + 2, y + 2, ts - 4, ts - 4);
        ctx.fillStyle = '#bac8d0';
        ctx.fillRect(x, y, ts, 2); ctx.fillRect(x, y, 2, ts);
        ctx.fillStyle = '#f0f8fc55';
        ctx.fillRect(x + 4, y + 4, ts * 0.35, 5);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(4, 3);
      return tex;
    }

    function makeBaseboardTex() {
      const [c, ctx] = mkCanvas(512, 128);
      ctx.fillStyle = '#6a7a8a'; ctx.fillRect(0, 0, 512, 128);
      for (let tx = 0; tx < 8; tx++) {
        const x = tx * 64;
        ctx.fillStyle = '#788898'; ctx.fillRect(x + 2, 2, 60, 124);
        ctx.strokeStyle = '#505a66'; ctx.lineWidth = 2; ctx.strokeRect(x + 2, 2, 60, 124);
        ctx.fillStyle = '#99aabb44'; ctx.fillRect(x + 5, 5, 18, 10);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(7, 1);
      return tex;
    }

    function makeFloorTex() {
      const [c, ctx] = mkCanvas(512, 512);
      const ts = 64;
      for (let tx = 0; tx < 8; tx++) for (let ty = 0; ty < 8; ty++) {
        const x = tx * ts, y = ty * ts;
        ctx.fillStyle = (tx + ty) % 2 === 0 ? '#b8cad4' : '#a6b8c2';
        ctx.fillRect(x, y, ts, ts);
        ctx.strokeStyle = '#7a8e98'; ctx.lineWidth = 2; ctx.strokeRect(x + 1, y + 1, ts - 2, ts - 2);
        ctx.fillStyle = '#d8eaf4aa'; ctx.fillRect(x + 3, y + 3, ts * 0.22, 5);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(6, 6);
      return tex;
    }

    function makeWhiteboardTex() {
      const [c, ctx] = mkCanvas(512, 256);
      ctx.fillStyle = '#f4f8f4'; ctx.fillRect(0, 0, 512, 256);
      ctx.fillStyle = '#7a8a7a'; ctx.fillRect(0, 0, 512, 8); ctx.fillRect(0, 248, 512, 8);
      ctx.fillRect(0, 0, 8, 256); ctx.fillRect(504, 0, 8, 256);
      ctx.fillStyle = '#9aaa9a'; ctx.fillRect(8, 240, 496, 8);
      // Benzene ring
      ctx.strokeStyle = '#1a3880'; ctx.lineWidth = 3;
      for (let i = 0; i < 6; i++) {
        const a = i * Math.PI / 3 - Math.PI / 6, a2 = (i + 1) * Math.PI / 3 - Math.PI / 6;
        ctx.beginPath(); ctx.moveTo(75 + Math.cos(a) * 36, 118 + Math.sin(a) * 36); ctx.lineTo(75 + Math.cos(a2) * 36, 118 + Math.sin(a2) * 36); ctx.stroke();
      }
      for (let i = 0; i < 3; i++) {
        const a1 = i * 2 * Math.PI / 3 - Math.PI / 6, a2 = (i * 2 + 1) * Math.PI / 3 - Math.PI / 6;
        ctx.beginPath(); ctx.moveTo(75 + Math.cos(a1) * 24, 118 + Math.sin(a1) * 24); ctx.lineTo(75 + Math.cos(a2) * 24, 118 + Math.sin(a2) * 24); ctx.stroke();
      }
      ctx.fillStyle = '#1a3880'; ctx.font = 'bold 18px Arial'; ctx.textAlign = 'left';
      ctx.fillText('C\u2086H\u2081\u2082O\u2086 + 6O\u2082  \u2192  6CO\u2082 + 6H\u2082O', 145, 68);
      ctx.font = '15px Arial'; ctx.fillStyle = '#1a6a1a';
      ctx.fillText('pH = 7.4   |   Temp: 37\u00b0C   |   Conc: 0.9%', 145, 102);
      ctx.fillStyle = '#8a1818'; ctx.font = '13px Arial';
      ctx.fillText('Sample A: Positive   |   Sample B: Negative', 145, 135);
      ctx.fillText('PCR Cycle #3  \u2192  Gel Electrophoresis', 145, 162);
      ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
      ctx.beginPath(); ctx.moveTo(20, 205); ctx.lineTo(492, 205); ctx.stroke();
      ctx.setLineDash([]);
      return new THREE.CanvasTexture(c);
    }

    function makeHazardTex(txt, bgcol) {
      const [c, ctx] = mkCanvas(256, 128);
      ctx.fillStyle = bgcol; ctx.fillRect(0, 0, 256, 128);
      ctx.fillStyle = '#111'; ctx.fillRect(4, 4, 248, 120);
      ctx.fillStyle = bgcol; ctx.fillRect(8, 8, 240, 112);
      // triangle
      ctx.fillStyle = '#111'; ctx.beginPath(); ctx.moveTo(48, 92); ctx.lineTo(78, 42); ctx.lineTo(108, 92); ctx.closePath(); ctx.fill();
      ctx.fillStyle = bgcol; ctx.beginPath(); ctx.moveTo(53, 88); ctx.lineTo(78, 48); ctx.lineTo(103, 88); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#111'; ctx.font = 'bold 13px Arial'; ctx.textAlign = 'center'; ctx.fillText('!', 78, 84);
      ctx.font = 'bold 19px Arial'; ctx.fillText(txt, 175, 68);
      ctx.font = '11px Arial'; ctx.fillText('SAFETY FIRST', 175, 92);
      return new THREE.CanvasTexture(c);
    }

    function makeExitTex() {
      const [c, ctx] = mkCanvas(256, 96);
      ctx.fillStyle = '#bb0000'; ctx.fillRect(0, 0, 256, 96);
      ctx.fillStyle = 'white'; ctx.font = 'bold 30px Arial'; ctx.textAlign = 'center'; ctx.fillText('EXIT', 128, 44);
      ctx.font = '14px Arial'; ctx.fillText('\u2192 EMERGENCY', 128, 72);
      ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.strokeRect(5, 5, 246, 86);
      return new THREE.CanvasTexture(c);
    }

    function makeSafetyPosterTex() {
      const [c, ctx] = mkCanvas(256, 384);
      ctx.fillStyle = '#fffae6'; ctx.fillRect(0, 0, 256, 384);
      ctx.fillStyle = '#cc3300'; ctx.fillRect(0, 0, 256, 52);
      ctx.fillStyle = 'white'; ctx.font = 'bold 17px Arial'; ctx.textAlign = 'center';
      ctx.fillText('\u26a0 LAB SAFETY', 128, 22); ctx.fillText('PROCEDURES', 128, 43);
      const rules = [
        '\ud83e\udd7c  Wear lab coat always',
        '\ud83e\udd7d  Safety goggles required',
        '\ud83e\udde4  Gloves for chemicals',
        '\ud83d\udeab  No food or drink in lab',
        '\ud83d\udd25  Know extinguisher location',
        '\ud83d\udeb6  Eyewash: rear wall',
        '\ud83d\udccb  Log all experiments',
        '\u267b\ufe0f   Dispose waste properly',
        '\u270b  Wash hands on exit',
      ];
      ctx.fillStyle = '#1a1a1a'; ctx.font = '12px Arial'; ctx.textAlign = 'left';
      rules.forEach((r, i) => ctx.fillText(r, 12, 78 + i * 32));
      ctx.fillStyle = '#cc3300'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
      ctx.fillText('EMERGENCY: CALL 911', 128, 368);
      ctx.strokeStyle = '#cc330066'; ctx.lineWidth = 3; ctx.strokeRect(4, 4, 248, 376);
      return new THREE.CanvasTexture(c);
    }

    function makePTableTex() {
      const [c, ctx] = mkCanvas(512, 320);
      ctx.fillStyle = '#eef2ff'; ctx.fillRect(0, 0, 512, 320);
      ctx.fillStyle = '#1a2870'; ctx.font = 'bold 15px Arial'; ctx.textAlign = 'center';
      ctx.fillText('PERIODIC TABLE OF ELEMENTS', 256, 20);
      const cols = ['#ff8888', '#ffbb66', '#ffee66', '#aaee66', '#66ddcc', '#88ccff', '#cc99ff', '#ff9999'];
      const rows = [['H', 'He'], ['Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne'], ['Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar'], ['K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn']];
      rows.forEach((row, ri) => row.forEach((el, ci) => {
        const x = 14 + ci * 27, y = 32 + ri * 62;
        ctx.fillStyle = cols[ri % cols.length] + 'bb'; ctx.fillRect(x, y, 22, 22);
        ctx.strokeStyle = '#33448888'; ctx.lineWidth = 1; ctx.strokeRect(x, y, 22, 22);
        ctx.fillStyle = '#1a2870'; ctx.font = 'bold 9px Arial'; ctx.textAlign = 'center';
        ctx.fillText(el, x + 11, y + 14);
      }));
      ctx.fillStyle = '#556677'; ctx.font = '10px Arial'; ctx.textAlign = 'left';
      ctx.fillText('Lab Reference \u2014 Rev. 2024', 10, 308);
      return new THREE.CanvasTexture(c);
    }

    function makeFumeHoodTex() {
      const [c, ctx] = mkCanvas(256, 256);
      ctx.fillStyle = '#c8d4de'; ctx.fillRect(0, 0, 256, 256);
      ctx.strokeStyle = '#a0b0be'; ctx.lineWidth = 2;
      for (let y = 0; y < 256; y += 28) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(256, y); ctx.stroke(); }
      ctx.fillStyle = '#ffcc00'; ctx.fillRect(48, 88, 160, 60);
      ctx.fillStyle = '#111'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
      ctx.fillText('FUME HOOD', 128, 110); ctx.fillText('KEEP SASH CLOSED', 128, 128); ctx.fillText('WHEN NOT IN USE', 128, 145);
      ctx.fillStyle = '#7788aa';
      for (let i = 0; i < 6; i++) ctx.fillRect(18 + i * 36, 180, 22, 56);
      return new THREE.CanvasTexture(c);
    }

    function makeBottleLabelTex(name, col) {
      const [c, ctx] = mkCanvas(128, 64);
      ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 128, 64);
      ctx.fillStyle = col + '33'; ctx.fillRect(0, 0, 128, 64);
      ctx.strokeStyle = col; ctx.lineWidth = 3; ctx.strokeRect(2, 2, 124, 60);
      ctx.fillStyle = '#111'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText(name, 64, 24);
      ctx.font = '10px Arial'; ctx.fillStyle = '#555'; ctx.fillText('Lab Grade', 64, 50);
      return new THREE.CanvasTexture(c);
    }

    // ── LAB SIMULATION ────────────────────────────────────────────────────────────
    function startLabSimulation() {
      hud.style.display = "block"; modeIndicator.style.display = "block";

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0f1a);
      scene.fog = new THREE.FogExp2(0x0a0f1a, 0.011);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
      camera.position.set(0, 3.2, 12);

      const renderer = new THREE.WebGLRenderer({ canvas: labCanvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.9;

      // Lighting
      scene.add(new THREE.AmbientLight(0xcce8ff, 1.1));
      [[-12, 7, -12], [0, 7, -12], [12, 7, -12], [-12, 7, 0], [0, 7, 0], [12, 7, 0], [-12, 7, 12], [0, 7, 12], [12, 7, 12]].forEach(([x, y, z]) => {
        const l = new THREE.PointLight(0xd0eeff, 0.9, 22);
        l.position.set(x, y, z); l.castShadow = true; l.shadow.mapSize.width = 512; l.shadow.mapSize.height = 512; l.shadow.radius = 4;
        scene.add(l);
        const sm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 2.5, 8), new THREE.MeshBasicMaterial({ color: 0xd0eeff, transparent: true, opacity: 0.9 }));
        sm.rotation.z = Math.PI / 2; sm.position.set(x, 7.15, z); scene.add(sm);
        const hm = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.8), new THREE.MeshBasicMaterial({ color: 0xd0eeff, transparent: true, opacity: 0.07, side: THREE.DoubleSide }));
        hm.position.set(x, 7.1, z); hm.rotation.x = Math.PI / 2; scene.add(hm);
      });
      const al1 = new THREE.PointLight(0x00e5ff, 0.3, 30);
      al1.position.set(-18, 3, -18); scene.add(al1);
      const al2 = new THREE.PointLight(0x7c4dff, 0.2, 30);
      al2.position.set(18, 3, 18); scene.add(al2);

      const roomW = 52, roomH = 9, roomD = 52, hw = 26, hd = 26;

      // ── FLOOR ──
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomW, roomD), new THREE.MeshStandardMaterial({ map: makeFloorTex(), roughness: 0.3, metalness: 0.1 }));
      floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);
      const refl = new THREE.Mesh(new THREE.PlaneGeometry(roomW, roomD), new THREE.MeshBasicMaterial({ color: 0xd0eeff, transparent: true, opacity: 0.03 }));
      refl.rotation.x = -Math.PI / 2; refl.position.y = 0.01; scene.add(refl);

      // ── CEILING with grid ──
      const ceil = new THREE.Mesh(new THREE.PlaneGeometry(roomW, roomD), new THREE.MeshStandardMaterial({ color: 0xe8eef4, roughness: 0.9 }));
      ceil.rotation.x = Math.PI / 2; ceil.position.y = roomH; scene.add(ceil);
      const barM = new THREE.MeshBasicMaterial({ color: 0xb0bcc8 });
      for (let x = -24; x <= 24; x += 4) { const b = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, roomD), barM); b.position.set(x, roomH - 0.01, 0); scene.add(b); }
      for (let z = -24; z <= 24; z += 4) { const b = new THREE.Mesh(new THREE.BoxGeometry(roomW, 0.02, 0.04), barM); b.position.set(0, roomH - 0.01, z); scene.add(b); }

      // ── WALLS: tiled panels with baseboard ──
      const wallTileMat = new THREE.MeshStandardMaterial({ map: makeWallTileTex(), roughness: 0.5, metalness: 0.02 });
      const baseboardMat = new THREE.MeshStandardMaterial({ map: makeBaseboardTex(), roughness: 0.4, metalness: 0.05 });

      function addWall(x, y, z, w, h, rotY) {
        const upperH = h - 1.2;
        const upper = new THREE.Mesh(new THREE.PlaneGeometry(w, upperH), wallTileMat);
        upper.position.set(x, y - h / 2 + 1.2 + upperH / 2, z); upper.rotation.y = rotY; upper.receiveShadow = true; scene.add(upper);
        const base = new THREE.Mesh(new THREE.PlaneGeometry(w, 1.2), baseboardMat);
        base.position.set(x, y - h / 2 + 0.6, z); base.rotation.y = rotY; scene.add(base);
        const trim = new THREE.Mesh(new THREE.BoxGeometry(rotY === 0 || rotY === Math.PI ? w : 0.05, 0.06, rotY === 0 || rotY === Math.PI ? 0.05 : w), new THREE.MeshStandardMaterial({ color: 0x3a4a58, roughness: 0.5, metalness: 0.3 }));
        trim.position.set(x, y - h / 2 + 1.22, z + (rotY === 0 ? 0.03 : 0)); scene.add(trim);
      }
      const cy = roomH / 2;
      addWall(0, cy, -hd + 0.03, roomW, roomH, 0);
      addWall(0, cy, hd - 0.03, roomW, roomH, Math.PI);
      addWall(-hw + 0.03, cy, 0, roomD, roomH, Math.PI / 2);
      addWall(hw - 0.03, cy, 0, roomD, roomH, -Math.PI / 2);

      // Teal accent strip near ceiling
      const accM = new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.35 });
      [{ p: [0, 8.3, -hd + 0.1], s: [roomW, 0.08, 0.08] }, { p: [0, 8.3, hd - 0.1], s: [roomW, 0.08, 0.08] },
      { p: [-hw + 0.1, 8.3, 0], s: [0.08, 0.08, roomD] }, { p: [hw - 0.1, 8.3, 0], s: [0.08, 0.08, roomD] }
      ].forEach(({ p, s }) => { const m = new THREE.Mesh(new THREE.BoxGeometry(...s), accM); m.position.set(...p); scene.add(m); });

      // ── FUME HOODS (back wall) ──
      function makeFumeHood(x, z, ry) {
        const g = new THREE.Group();
        const bM = new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 0.5, metalness: 0.1 });
        const fumeBody = new THREE.Mesh(new THREE.BoxGeometry(2.4, 2.2, 0.8), bM); fumeBody.position.set(0, 1.1, 0); g.add(fumeBody);
        const sM = new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.28, roughness: 0.05 });
        const sash = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.85, 0.04), sM); sash.position.set(0, 1.42, 0.42); g.add(sash);
        const fM = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.4, metalness: 0.4 });
        [[0, 1.9, 0.42], [0, 0.96, 0.42]].forEach(p => { const m = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.06, 0.06), fM); m.position.set(...p); g.add(m); });
        const bp = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 2.0), new THREE.MeshStandardMaterial({ map: makeFumeHoodTex(), roughness: 0.6 }));
        bp.position.set(0, 1.0, -0.38); g.add(bp);
        const wM = new THREE.MeshStandardMaterial({ color: 0x2a3444, roughness: 0.3, metalness: 0.15 });
        const ws = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.06, 0.8), wM); ws.position.y = 0; g.add(ws);
        [-1.2, 1.2].forEach(dx => { const sw = new THREE.Mesh(new THREE.BoxGeometry(0.04, 2.2, 0.8), new THREE.MeshStandardMaterial({ color: 0x667788, roughness: 0.4 })); sw.position.set(dx, 1.1, 0); g.add(sw); });
        const lg = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ff44 })); lg.position.set(0.85, 2.15, 0.35); g.add(lg);
        const lr = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff3300 })); lr.position.set(0.62, 2.15, 0.35); g.add(lr);
        const lbl = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 0.28), new THREE.MeshStandardMaterial({ map: makeHazardTex('FUME HOOD', '#ffcc00'), roughness: 0.5 }));
        lbl.position.set(0, 2.1, 0.41); g.add(lbl);
        g.position.set(x, 0, z); g.rotation.y = ry; scene.add(g);
      }
      makeFumeHood(-16, -hd + 0.8, 0); makeFumeHood(-6, -hd + 0.8, 0);
      makeFumeHood(6, -hd + 0.8, 0); makeFumeHood(16, -hd + 0.8, 0);

      // ── WALL CABINETS (back wall upper) ──
      const wcM = new THREE.MeshStandardMaterial({ color: 0x9aafc0, roughness: 0.5, metalness: 0.05 });
      const wdM = new THREE.MeshStandardMaterial({ color: 0xb0c8d8, roughness: 0.35, metalness: 0.12 });
      const whM = new THREE.MeshStandardMaterial({ color: 0xe0e8f0, roughness: 0.2, metalness: 0.8 });
      [-22, -8, 8, 22].forEach(x => {
        const cab = new THREE.Mesh(new THREE.BoxGeometry(3.2, 1.4, 0.55), wcM);
        cab.position.set(x, 6.3, -hd + 0.55); cab.castShadow = true; scene.add(cab);
        [-0.82, 0.82].forEach(dx => {
          const d = new THREE.Mesh(new THREE.BoxGeometry(1.44, 1.2, 0.05), wdM);
          d.position.set(x + dx, 6.3, -hd + 0.84); scene.add(d);
          const h = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.35, 8), whM);
          h.rotation.z = Math.PI / 2; h.position.set(x + dx, 6.3, -hd + 0.88); scene.add(h);
        });
      });

      // ── WHITEBOARD (right wall) ──
      const wbFrM = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.4, metalness: 0.3 });
      const wbFr = new THREE.Mesh(new THREE.BoxGeometry(0.06, 3.0, 5.5), wbFrM);
      wbFr.position.set(hw - 0.04, 4.5, -4); scene.add(wbFr);
      const wb = new THREE.Mesh(new THREE.PlaneGeometry(5.0, 2.6), new THREE.MeshStandardMaterial({ map: makeWhiteboardTex(), roughness: 0.05 }));
      wb.rotation.y = -Math.PI / 2; wb.position.set(hw - 0.07, 4.5, -4); scene.add(wb);
      const wbTray = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 5.0), wbFrM);
      wbTray.position.set(hw - 0.04, 3.17, -4); scene.add(wbTray);
      ['#ff4444', '#4488ff', '#44aa44', '#111111'].forEach((col, i) => {
        const mk = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.018, 0.28, 8), new THREE.MeshStandardMaterial({ color: parseInt(col.replace('#', '0x')), roughness: 0.5 }));
        mk.rotation.x = Math.PI / 2; mk.position.set(hw - 0.09, 3.19, -2.4 + i * 0.42); scene.add(mk);
      });

      // ── PERIODIC TABLE POSTER (right wall) ──
      const ptFr = new THREE.Mesh(new THREE.BoxGeometry(0.05, 2.3, 3.7), new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.5 }));
      ptFr.position.set(hw - 0.04, 5.2, 8); scene.add(ptFr);
      const pt = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 2.1), new THREE.MeshStandardMaterial({ map: makePTableTex(), roughness: 0.7 }));
      pt.rotation.y = -Math.PI / 2; pt.position.set(hw - 0.06, 5.2, 8); scene.add(pt);

      // ── SAFETY POSTER (left wall) ──
      const spFr = new THREE.Mesh(new THREE.BoxGeometry(0.05, 2.2, 1.5), new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.5 }));
      spFr.position.set(-hw + 0.04, 4.5, 15); scene.add(spFr);
      const sp = new THREE.Mesh(new THREE.PlaneGeometry(1.35, 2.05), new THREE.MeshStandardMaterial({ map: makeSafetyPosterTex(), roughness: 0.7 }));
      sp.rotation.y = Math.PI / 2; sp.position.set(-hw + 0.06, 4.5, 15); scene.add(sp);

      // ── HAZARD SIGNS (back wall) ──
      [{ x: -10, lbl: 'BIOHAZARD', c: '#cc2200' }, { x: 0, lbl: 'CHEMICAL', c: '#ff8800' }, { x: 10, lbl: 'FLAMMABLE', c: '#ff5500' }].forEach(({ x, lbl, c }) => {
        const s = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.35), new THREE.MeshStandardMaterial({ map: makeHazardTex(lbl, c), roughness: 0.6 }));
        s.position.set(x, 2.7, -hd + 0.05); scene.add(s);
      });

      // ── EXIT SIGN ──
      const exitS = new THREE.Mesh(new THREE.PlaneGeometry(0.85, 0.38), new THREE.MeshStandardMaterial({ map: makeExitTex(), roughness: 0.5 }));
      exitS.position.set(0, 8.1, hd - 0.07); exitS.rotation.y = Math.PI; scene.add(exitS);
      const exitL = new THREE.PointLight(0xff0000, 0.4, 3); exitL.position.set(0, 7.7, hd - 0.3); scene.add(exitL);

      // ── REAGENT SHELVES (left wall) ──
      function addShelf(wx, y, wz) {
        const shM = new THREE.MeshStandardMaterial({ color: 0x667788, roughness: 0.4, metalness: 0.35 });
        const sh = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.06, 0.38), shM); sh.position.set(wx, y, wz); scene.add(sh);
        // Shelf back panel
        const bp = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.5, 4.2), shM); bp.position.set(wx - 0.17, y - 0.25, wz); scene.add(bp);
        const bottles = [
          { name: 'HCl', col: 0xff4444, dx: -1.65 }, { name: 'NaOH', col: 0xff8800, dx: -1.05 },
          { name: 'H\u2082O\u2082', col: 0x4488ff, dx: -0.45 }, { name: 'EtOH', col: 0x44bb44, dx: 0.15 },
          { name: 'HNO\u2083', col: 0xffcc00, dx: 0.75 }, { name: 'Buffer', col: 0xaa44ff, dx: 1.35 },
        ];
        bottles.forEach(({ name, col, dx }) => {
          const bh = 0.27 + Math.random() * 0.1;
          const bm = new THREE.MeshStandardMaterial({ color: col, transparent: true, opacity: 0.7, roughness: 0.1 });
          const bot = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.075, bh, 10), bm);
          bot.position.set(wx + dx, y + bh / 2 + 0.04, wz); scene.add(bot);
          const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.04, 10), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }));
          cap.position.set(wx + dx, y + bh + 0.06, wz); scene.add(cap);
          const lbl = new THREE.Mesh(new THREE.PlaneGeometry(0.11, 0.055), new THREE.MeshStandardMaterial({ map: makeBottleLabelTex(name, '#' + col.toString(16).padStart(6, '0')), roughness: 0.5 }));
          lbl.position.set(wx + dx, y + bh * 0.45 + 0.04, wz + 0.08); scene.add(lbl);
        });
      }
      addShelf(-hw + 0.55, 4.5, -10); addShelf(-hw + 0.55, 3.4, -10);
      addShelf(-hw + 0.55, 4.5, 6); addShelf(-hw + 0.55, 3.4, 6);

      // ── FIRE EXTINGUISHERS ──
      function addFireExt(x, z) {
        const rM = new THREE.MeshStandardMaterial({ color: 0xcc2200, roughness: 0.3, metalness: 0.5 });
        const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.72, 12), rM); tank.position.set(x, 0.5, z); scene.add(tank);
        const top = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2), rM); top.position.set(x, 0.86, z); scene.add(top);
        const hose = new THREE.Mesh(new THREE.CylinderGeometry(0.014, 0.014, 0.3, 8), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }));
        hose.rotation.z = Math.PI / 4; hose.position.set(x + 0.15, 0.96, z); scene.add(hose);
        const brk = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.5, 0.08), rM); brk.position.set(x, 0.5, z + 0.18); scene.add(brk);
      }
      addFireExt(-hw + 0.3, -hd + 0.45); addFireExt(hw - 0.3, -hd + 0.45); addFireExt(-hw + 0.3, hd - 0.45);

      // ── EYEWASH STATIONS ──
      function addEyewash(x, z) {
        const gM = new THREE.MeshStandardMaterial({ color: 0x33aa44, roughness: 0.3, metalness: 0.3 });
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.20, 0.9, 12), gM); base.position.set(x, 0.45, z); scene.add(base);
        const bowl = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshStandardMaterial({ color: 0xeef8ee, roughness: 0.15 }));
        bowl.rotation.x = Math.PI; bowl.position.set(x, 0.9, z); scene.add(bowl);
        const sign = new THREE.Mesh(new THREE.PlaneGeometry(0.55, 0.24), new THREE.MeshStandardMaterial({ map: makeHazardTex('EYEWASH', '#00aa44'), roughness: 0.6 }));
        sign.position.set(x, 1.48, z + 0.06); scene.add(sign);
      }
      addEyewash(22, -hd + 0.5); addEyewash(-22, -hd + 0.5);

      // ── SINKS (left wall) ──
      function addSink(x, z) {
        const sM = new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 0.5 });
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.9, 0.58), sM); base.position.set(x, 0.45, z); scene.add(base);
        const top = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.06, 0.58), new THREE.MeshStandardMaterial({ color: 0xd4e0e8, roughness: 0.2, metalness: 0.3 }));
        top.position.set(x, 0.92, z); scene.add(top);
        const basin = new THREE.Mesh(new THREE.BoxGeometry(0.68, 0.14, 0.38), new THREE.MeshStandardMaterial({ color: 0xeaf4f8, roughness: 0.1 }));
        basin.position.set(x, 0.87, z); scene.add(basin);
        const fM = new THREE.MeshStandardMaterial({ color: 0xc8d4dc, roughness: 0.1, metalness: 0.9 });
        const fb = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.028, 0.24, 8), fM); fb.position.set(x, 1.1, z - 0.14); scene.add(fb);
        const fa = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.018, 0.18, 8), fM); fa.rotation.x = Math.PI / 4; fa.position.set(x, 1.21, z - 0.08); scene.add(fa);
      }
      addSink(-hw + 0.45, -6); addSink(-hw + 0.45, 5); addSink(-hw + 0.45, 15);

      // ── WALL OUTLETS ──
      const plM = new THREE.MeshStandardMaterial({ color: 0xeef4f8, roughness: 0.7 });
      for (let wz = -20; wz <= 20; wz += 6) {
        [-hw + 0.04, hw - 0.04].forEach((wx, si) => {
          const pl = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.18, 0.02), plM);
          pl.position.set(wx, 1.4, wz); pl.rotation.y = si === 0 ? Math.PI / 2 : -Math.PI / 2; scene.add(pl);
        });
      }

      // ── LAB TABLES ──
      function makeLabTable(x, z) {
        const g = new THREE.Group();
        const topM = new THREE.MeshStandardMaterial({ color: 0xf0f4f8, roughness: 0.3, metalness: 0.05 });
        const top = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.08, 1.8), topM); top.position.y = 1.8; top.castShadow = true; top.receiveShadow = true; g.add(top);
        const edgeM = new THREE.MeshStandardMaterial({ color: 0x2a3a4a, roughness: 0.4, metalness: 0.2 });
        [0.92, -0.92].forEach(ez => { const e = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.09, 0.04), edgeM); e.position.set(0, 1.8, ez); g.add(e); });
        const cabM = new THREE.MeshStandardMaterial({ color: 0x9aafbf, roughness: 0.6, metalness: 0.05 });
        const cab = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.9, 1.6), cabM); cab.position.y = 1.3; cab.castShadow = true; g.add(cab);
        const doorM = new THREE.MeshStandardMaterial({ color: 0xb0c4d4, roughness: 0.4, metalness: 0.08 });
        [-0.76, 0.76].forEach(dx => {
          const d = new THREE.Mesh(new THREE.BoxGeometry(1.38, 0.82, 0.04), doorM); d.position.set(dx, 1.3, 0.82); g.add(d);
          const hnd = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.35, 8), new THREE.MeshStandardMaterial({ color: 0xe0e8f0, roughness: 0.2, metalness: 0.8 }));
          hnd.rotation.z = Math.PI / 2; hnd.position.set(dx, 1.3, 0.87); g.add(hnd);
        });
        const legM = new THREE.MeshStandardMaterial({ color: 0xd0d8e0, roughness: 0.3, metalness: 0.7 });
        [[-1.4, 0.7], [1.4, 0.7], [-1.4, -0.7], [1.4, -0.7]].forEach(([lx, lz]) => {
          const leg = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.84, 0.07), legM); leg.position.set(lx, 0.42, lz); leg.castShadow = true; g.add(leg);
          const foot = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.06, 0.05, 8), new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 }));
          foot.position.set(lx, 0.025, lz); g.add(foot);
        });
        const brM = new THREE.MeshStandardMaterial({ color: 0xc0c8d0, roughness: 0.4, metalness: 0.5 });
        const br = new THREE.Mesh(new THREE.BoxGeometry(2.82, 0.05, 0.05), brM); br.position.y = 0.6; g.add(br);
        // Gas tap
        const tapM = new THREE.MeshStandardMaterial({ color: 0x0044aa, roughness: 0.3, metalness: 0.6 });
        const tapB = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.08, 8), new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.3, metalness: 0.7 }));
        tapB.position.set(1.2, 1.86, 0); g.add(tapB);
        const tapH = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.02, 0.04), tapM); tapH.position.set(1.2, 1.95, 0); g.add(tapH);
        // Water tap
        const wtM = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.1, metalness: 0.9 });
        const wt = new THREE.Mesh(new THREE.CylinderGeometry(0.022, 0.022, 0.14, 8), wtM); wt.rotation.z = Math.PI / 6; wt.position.set(0.9, 1.93, 0); g.add(wt);
        g.position.set(x, 0, z); scene.add(g);
        return g;
      }

      function addEquipment(x, z) {
        const eqM = new THREE.MeshStandardMaterial({ color: 0x2a3a4a, roughness: 0.4, metalness: 0.6 });
        // Microscope
        const mB = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.28, 0.06, 12), eqM); mB.position.set(x, 1.87, z); scene.add(mB);
        const mA = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.68, 8), eqM); mA.position.set(x, 2.22, z); scene.add(mA);
        const mH = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.17, 0.14), new THREE.MeshStandardMaterial({ color: 0x1a2a3a, roughness: 0.3, metalness: 0.7 }));
        mH.position.set(x + 0.12, 2.56, z); scene.add(mH);
        const ep = new THREE.Mesh(new THREE.CylinderGeometry(0.024, 0.024, 0.12, 8), new THREE.MeshStandardMaterial({ color: 0x111, roughness: 0.2, metalness: 0.5 }));
        ep.position.set(x + 0.12, 2.67, z); scene.add(ep);
        // Beaker
        const bkM = new THREE.MeshStandardMaterial({ color: 0x88c8ff, transparent: true, opacity: 0.45, roughness: 0.05 });
        const bk = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.07, 0.22, 12), bkM); bk.position.set(x - 0.5, 1.95, z + 0.2); scene.add(bk);
        const lqM = new THREE.MeshStandardMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.7, roughness: 0.1 });
        const lq = new THREE.Mesh(new THREE.CylinderGeometry(0.075, 0.06, 0.12, 12), lqM); lq.position.set(x - 0.5, 1.9, z + 0.2); scene.add(lq);
        // Petri dish
        const dsM = new THREE.MeshStandardMaterial({ color: 0xeef4ff, transparent: true, opacity: 0.5, roughness: 0.1 });
        const ds = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.14, 0.03, 16), dsM); ds.position.set(x + 0.4, 1.855, z - 0.2); scene.add(ds);
        // Erlenmeyer flask
        const flM = new THREE.MeshStandardMaterial({ color: 0x99ddff, transparent: true, opacity: 0.5, roughness: 0.05 });
        const flB = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.14, 10), flM); flB.position.set(x - 0.35, 1.93, z - 0.25); scene.add(flB);
        const flN = new THREE.Mesh(new THREE.CylinderGeometry(0.032, 0.1, 0.11, 10), flM); flN.position.set(x - 0.35, 2.03, z - 0.25); scene.add(flN);
        // Notebook + pen
        const nb = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.02, 0.17), new THREE.MeshStandardMaterial({ color: 0x223355, roughness: 0.8 }));
        nb.position.set(x + 0.65, 1.85, z + 0.3); nb.rotation.y = 0.2; scene.add(nb);
        const pn = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.2, 6), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 }));
        pn.rotation.z = Math.PI / 2; pn.position.set(x + 0.65, 1.87, z + 0.42); scene.add(pn);
      }

      [[-15, -15], [-5, -15], [5, -15], [15, -15], [-15, 0], [-5, 0], [5, 0], [15, 0], [-15, 15], [-5, 15], [5, 15], [15, 15]].forEach(([x, z]) => {
        makeLabTable(x, z); addEquipment(x, z);
      });

      // ── PLAYER ──
      const player = new THREE.Group(); scene.add(player);
      const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xeef4ff, roughness: 0.9 }));
      body.position.y = 2.1; body.castShadow = true; player.add(body);
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.6, 0.55), new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.9 }));
      head.position.y = 3.2; head.castShadow = true; player.add(head);
      const legM = new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.9 });
      const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.28, 1.0, 0.28), legM); leftLeg.position.set(-0.2, 1.0, 0); leftLeg.castShadow = true; player.add(leftLeg);
      const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.28, 1.0, 0.28), legM); rightLeg.position.set(0.2, 1.0, 0); rightLeg.castShadow = true; player.add(rightLeg);
      player.position.set(0, 0, 6);

      // ── CONTROLS ──
      const keys = {};
      document.addEventListener("keydown", e => {
        keys[e.code] = true;
        if (e.code === "Digit5") { firstPerson = !firstPerson; modeIndicator.textContent = firstPerson ? "FIRST PERSON" : "THIRD PERSON"; }
      });
      document.addEventListener("keyup", e => keys[e.code] = false);

      let firstPerson = true, walkTime = 0;
      const half = roomW / 2 - 1;
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let targetPos = null;
      const moveSpeed = 0.15;

      const markerMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, side: THREE.DoubleSide });
      const clickMarker = new THREE.Mesh(new THREE.RingGeometry(0.2, 0.3, 32), markerMat);
      clickMarker.rotation.x = -Math.PI / 2; clickMarker.position.y = 0.05; clickMarker.visible = false; scene.add(clickMarker);
      const pulseMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
      const pulseRing = new THREE.Mesh(new THREE.RingGeometry(0.25, 0.33, 32), pulseMat);
      pulseRing.rotation.x = -Math.PI / 2; pulseRing.position.y = 0.06; pulseRing.visible = false; scene.add(pulseRing);

      window.addEventListener('mousedown', event => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(floor);
        if (hits.length > 0) {
          const pt = hits[0].point;
          const cx = Math.max(-half, Math.min(half, pt.x));
          const cz = Math.max(-half, Math.min(half, pt.z));
          targetPos = new THREE.Vector3(cx, player.position.y, cz);
          clickMarker.position.set(cx, 0.05, cz); clickMarker.visible = true;
          pulseRing.position.set(cx, 0.06, cz); pulseRing.visible = true;
        }
      });

      const tpOffset = new THREE.Vector3(0, 28, 18);
      let tpCamPos = player.position.clone().add(tpOffset);

      function animateLab() {
        requestAnimationFrame(animateLab);
        let walking = false;
        if (targetPos) {
          const dist = player.position.distanceTo(targetPos);
          if (dist > 0.12) {
            const dir = new THREE.Vector3().subVectors(targetPos, player.position).normalize();
            player.position.addScaledVector(dir, moveSpeed);
            const ta = Math.atan2(dir.x, dir.z);
            let delta = ta - player.rotation.y;
            while (delta > Math.PI) delta -= Math.PI * 2;
            while (delta < -Math.PI) delta += Math.PI * 2;
            player.rotation.y += delta * 0.15;
            walking = true;
          } else {
            targetPos = null; clickMarker.visible = false; pulseRing.visible = false;
          }
        }
        if (keys["KeyQ"]) player.rotation.y += 0.04;
        if (keys["KeyE"]) player.rotation.y -= 0.04;
        player.position.x = Math.max(-half, Math.min(half, player.position.x));
        player.position.z = Math.max(-half, Math.min(half, player.position.z));
        if (walking) {
          walkTime += 0.25;
          leftLeg.rotation.x = Math.sin(walkTime) * 0.7; rightLeg.rotation.x = -Math.sin(walkTime) * 0.7;
          body.position.y = 2.1 + Math.abs(Math.sin(walkTime * 2)) * 0.02;
        } else {
          leftLeg.rotation.x = 0; rightLeg.rotation.x = 0; body.position.y = 2.1;
        }
        if (pulseRing.visible) {
          const t = Date.now() * 0.003;
          pulseMat.opacity = 0.28 + Math.sin(t * 4) * 0.22;
          const s = 1 + Math.sin(t * 4) * 0.15; pulseRing.scale.set(s, 1, s);
        }
        if (firstPerson) {
          const eye = new THREE.Vector3(0, 3.35, 0).applyQuaternion(player.quaternion).add(player.position);
          camera.position.copy(eye);
          const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(player.quaternion);
          camera.lookAt(eye.clone().add(fwd));
        } else {
          tpCamPos.lerp(player.position.clone().add(tpOffset), 0.08);
          camera.position.copy(tpCamPos); camera.lookAt(player.position);
        }
        const ft = Date.now() * 0.001;
        scene.children.forEach(c => { if (c.isPointLight && c.color.b > 0.8) c.intensity = 1.0 + Math.sin(ft * 60 + c.position.x) * 0.01; });
        renderer.render(scene, camera);
      }
      animateLab();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    window.addEventListener("resize", () => {
      entryCamera.aspect = window.innerWidth / window.innerHeight;
      entryCamera.updateProjectionMatrix();
      entryRenderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>